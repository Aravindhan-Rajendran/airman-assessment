import { PrismaClient } from '@prisma/client';
import bcrypt from 'bcrypt';

const prisma = new PrismaClient();
const SALT_ROUNDS = 12;

async function main() {
  const schoolA = await prisma.tenant.upsert({
    where: { slug: 'flight-school-alpha' },
    update: {},
    create: { name: 'Flight School Alpha', slug: 'flight-school-alpha' },
  });
  const schoolB = await prisma.tenant.upsert({
    where: { slug: 'flight-school-beta' },
    update: {},
    create: { name: 'Flight School Beta', slug: 'flight-school-beta' },
  });

  const adminPassword = await bcrypt.hash('Admin123!', SALT_ROUNDS);
  const userPassword = await bcrypt.hash('Password123!', SALT_ROUNDS);

  await prisma.user.upsert({
    where: { tenantId_email: { tenantId: schoolA.id, email: 'admin@schoolalpha.com' } },
    update: { passwordHash: adminPassword },
    create: {
      tenantId: schoolA.id,
      email: 'admin@schoolalpha.com',
      passwordHash: adminPassword,
      role: 'ADMIN',
      approved: true,
    },
  });
  const instructorA = await prisma.user.upsert({
    where: { tenantId_email: { tenantId: schoolA.id, email: 'instructor@schoolalpha.com' } },
    update: { passwordHash: userPassword },
    create: {
      tenantId: schoolA.id,
      email: 'instructor@schoolalpha.com',
      passwordHash: userPassword,
      role: 'INSTRUCTOR',
      approved: true,
    },
  });
  const studentA = await prisma.user.upsert({
    where: { tenantId_email: { tenantId: schoolA.id, email: 'student@schoolalpha.com' } },
    update: { passwordHash: userPassword },
    create: {
      tenantId: schoolA.id,
      email: 'student@schoolalpha.com',
      passwordHash: userPassword,
      role: 'STUDENT',
      approved: true,
    },
  });
  await prisma.user.upsert({
    where: { tenantId_email: { tenantId: schoolA.id, email: 'pending@schoolalpha.com' } },
    update: { passwordHash: userPassword },
    create: {
      tenantId: schoolA.id,
      email: 'pending@schoolalpha.com',
      passwordHash: userPassword,
      role: 'STUDENT',
      approved: false,
    },
  });

  await prisma.user.upsert({
    where: { tenantId_email: { tenantId: schoolB.id, email: 'admin@schoolbeta.com' } },
    update: { passwordHash: adminPassword },
    create: {
      tenantId: schoolB.id,
      email: 'admin@schoolbeta.com',
      passwordHash: adminPassword,
      role: 'ADMIN',
      approved: true,
    },
  });
  await prisma.user.upsert({
    where: { tenantId_email: { tenantId: schoolB.id, email: 'instructor@schoolbeta.com' } },
    update: { passwordHash: userPassword },
    create: {
      tenantId: schoolB.id,
      email: 'instructor@schoolbeta.com',
      passwordHash: userPassword,
      role: 'INSTRUCTOR',
      approved: true,
    },
  });
  await prisma.user.upsert({
    where: { tenantId_email: { tenantId: schoolB.id, email: 'student@schoolbeta.com' } },
    update: { passwordHash: userPassword },
    create: {
      tenantId: schoolB.id,
      email: 'student@schoolbeta.com',
      passwordHash: userPassword,
      role: 'STUDENT',
      approved: true,
    },
  });

  const sampleCourseTitles = [
    'Advanced React Architecture',
    'Secure Backend Engineering with Node',
    'Database Design & Optimization',
    'System Design Fundamentals',
    'API Security & JWT Mastery',
  ];

  for (const title of sampleCourseTitles) {
    const existing = await prisma.course.findFirst({
      where: { tenantId: schoolA.id, title },
    });
    if (!existing) {
      await prisma.course.create({
        data: {
          tenantId: schoolA.id,
          title,
          description: `Sample course: ${title}`,
          createdById: instructorA.id,
        },
      });
    }
  }

  let course1 = await prisma.course.findFirst({
    where: { tenantId: schoolA.id, title: 'Private Pilot Ground' },
  });
  if (!course1) {
    course1 = await prisma.course.create({
      data: {
        tenantId: schoolA.id,
        title: 'Private Pilot Ground',
        description: 'Ground school for PPL',
        createdById: instructorA.id,
      },
    });
  }

  let mod1 = await prisma.module.findFirst({ where: { courseId: course1.id } });
  if (!mod1) {
    mod1 = await prisma.module.create({
      data: { courseId: course1.id, title: 'Aerodynamics', order: 0 },
    });
  }

  const existingLesson1 = await prisma.lesson.findFirst({
    where: { moduleId: mod1.id, title: 'Lift and Drag' },
  });
  if (!existingLesson1) {
    await prisma.lesson.create({
      data: {
        moduleId: mod1.id,
        title: 'Lift and Drag',
        type: 'TEXT',
        content: 'Lift is generated by the wings...',
        order: 0,
      },
    });
  }

  const existingQuiz = await prisma.lesson.findFirst({
    where: { moduleId: mod1.id, title: 'Aerodynamics Quiz' },
  });
  if (!existingQuiz) {
    await prisma.lesson.create({
      data: {
        moduleId: mod1.id,
        title: 'Aerodynamics Quiz',
        type: 'QUIZ',
        content: JSON.stringify({
          questions: [
            {
              id: 'q1',
              text: 'What creates lift?',
              options: [
                { id: 'a', text: 'Engine' },
                { id: 'b', text: 'Wing shape and AOA' },
                { id: 'c', text: 'Rudder' },
              ],
              correctOptionId: 'b',
            },
          ],
        }),
        order: 1,
      },
    });
  }

  const nextWeek = new Date();
  nextWeek.setDate(nextWeek.getDate() + 7);
  const slotStart = new Date(nextWeek);
  slotStart.setHours(9, 0, 0, 0);
  const slotEnd = new Date(nextWeek);
  slotEnd.setHours(12, 0, 0, 0);
  const existingAvail = await prisma.instructorAvailability.findFirst({
    where: { tenantId: schoolA.id, instructorId: instructorA.id },
  });
  if (!existingAvail) {
    await prisma.instructorAvailability.create({
      data: {
        tenantId: schoolA.id,
        instructorId: instructorA.id,
        startAt: slotStart,
        endAt: slotEnd,
      },
    });
  }

  const existingBooking = await prisma.booking.findFirst({
    where: { tenantId: schoolA.id, studentId: studentA.id },
  });
  if (!existingBooking) {
    const bookStart = new Date(nextWeek);
    bookStart.setHours(10, 0, 0, 0);
    const bookEnd = new Date(nextWeek);
    bookEnd.setHours(11, 0, 0, 0);
    await prisma.booking.create({
      data: {
        tenantId: schoolA.id,
        studentId: studentA.id,
        status: 'REQUESTED',
        requestedAt: new Date(),
        startAt: bookStart,
        endAt: bookEnd,
      },
    });
  }

  console.log('Seed complete:', {
    tenants: [schoolA.slug, schoolB.slug],
    sampleCourses: sampleCourseTitles.length + 1,
  });
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(() => prisma.$disconnect());
